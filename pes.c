/** @file
 *
 * This file has been automatically generated by the WICED Smart Designer. 
 * Device configuration and functions required for the BLE device.
 *
 */
//#include <stdbool.h>
#include "bleprofile.h"
#include "bleapp.h"
#include "gpiodriver.h"
#include "string.h"
#include "stdio.h"
#include "platform.h"


// Include sensor headers
//#include "hts221_driver.h"
//#include "l3gd20_driver.h"
//#include "lis3dsh_driver.h"
//#include "lps25h_driver.h"
//#include "lsm303d_driver.h"

#include "pes_db.h"

/* add adc <meehan@parc.com> */
#include "adc.h"

/******************************************************
 *                     Constants
 ******************************************************/

#define pes_FINE_TIMER           10
#define pes_DEVICE_NAME          "pes"
#define pes_DEVICE_APPEARENCE    0
#define pes_MAIN_SERVICE_UUID    __UUID_SENSOR_SERVICE
#define pes_MAIN_CHAR_UUID       __UUID_SENSOR_SERVICE_TEMPERATURE
#define pes_MAIN_CHAR_HANDLE     HDLC_SENSOR_SERVICE_TEMPERATURE_VALUE

/******************************************************
 *                     Structures
 ******************************************************/

#pragma pack(1)
//host information for NVRAM
typedef PACKED struct
{
    //part of HOSTINFO generated by wizard
    __HOSTINFO generated;
    // ToDo: add your variables here which need to be saved in the NVRAM
}  HOSTINFO;
#pragma pack()

/******************************************************
 *               Function Prototypes
 ******************************************************/

static void pes_create(void);
static void pes_connection_up( void );
static void pes_connection_down( void );
static void pes_advertisement_stopped( void );
static void pes_smp_bond_result( LESMP_PARING_RESULT result );
static void pes_encryption_changed( HCI_EVT_HDR *evt );
static int  pes_write_handler( LEGATTDB_ENTRY_HDR *p );
static void pes_interrupt_handler( UINT8 value );

/******************************************************
 *               Variables Definitions
 ******************************************************/

const BLE_PROFILE_CFG pes_cfg =
{
    /*.fine_timer_interval            =*/ pes_FINE_TIMER, // ms
    /*.default_adv                    =*/ 4,    // HIGH_UNDIRECTED_DISCOVERABLE
    /*.button_adv_toggle              =*/ 0,    // pairing button make adv toggle (if 1) or always on (if 0)
    /*.high_undirect_adv_interval     =*/ 32,   // slots
    /*.low_undirect_adv_interval      =*/ 1024, // slots
    /*.high_undirect_adv_duration     =*/ 30,   // seconds
    /*.low_undirect_adv_duration      =*/ 300,  // seconds
    /*.high_direct_adv_interval       =*/ 0,    // seconds
    /*.low_direct_adv_interval        =*/ 0,    // seconds
    /*.high_direct_adv_duration       =*/ 0,    // seconds
    /*.low_direct_adv_duration        =*/ 0,    // seconds
    /*.local_name                     =*/ pes_DEVICE_NAME, // [LOCAL_NAME_LEN_MAX];
    /*.cod                            =*/ BIT16_TO_8(pes_DEVICE_APPEARENCE),0x00, // [COD_LEN];
    /*.ver                            =*/ "1.00",         // [VERSION_LEN];
    /*.encr_required                  =*/ 0,    //(SECURITY_ENABLED | SECURITY_REQUEST),    // data encrypted and device sends security request on every connection
    /*.disc_required                  =*/ 0,    // if 1, disconnection after confirmation
    /*.test_enable                    =*/ 1,    // TEST MODE is enabled when 1
    /*.tx_power_level                 =*/ 0x04, // dbm
    /*.con_idle_timeout               =*/ 30,   // second  0-> no timeout
    /*.powersave_timeout              =*/ 0,    // second  0-> no timeout
    /*.hdl                            =*/ {pes_MAIN_CHAR_HANDLE, 0x00, 0x00, 0x00, 0x00}, // [HANDLE_NUM_MAX];
    /*.serv                           =*/ {pes_MAIN_SERVICE_UUID, 0x00, 0x00, 0x00, 0x00},
    /*.cha                            =*/ {pes_MAIN_CHAR_UUID, 0x00, 0x00, 0x00, 0x00},
    /*.findme_locator_enable          =*/ 0,    // if 1 Find me locator is enable
    /*.findme_alert_level             =*/ 0,    // alert level of find me
    /*.client_grouptype_enable        =*/ 0,    // if 1 grouptype read can be used
    /*.linkloss_button_enable         =*/ 0,    // if 1 linkloss button is enable
    /*.pathloss_check_interval        =*/ 0,    // second
    /*.alert_interval                 =*/ 0,    // interval of alert
    /*.high_alert_num                 =*/ 0,    // number of alert for each interval
    /*.mild_alert_num                 =*/ 0,    // number of alert for each interval
    /*.status_led_enable              =*/ 1,    // if 1 status LED is enable
    /*.status_led_interval            =*/ 1,    // second
    /*.status_led_con_blink           =*/ 1,    // blink num of connection
    /*.status_led_dir_adv_blink       =*/ 0,    // blink num of dir adv
    /*.status_led_un_adv_blink        =*/ 0,    // blink num of undir adv
    /*.led_on_ms                      =*/ 200,    // led blink on duration in ms
    /*.led_off_ms                     =*/ 800,    // led blink off duration in ms
    /*.buz_on_ms                      =*/ 0,  // buzzer on duration in ms
    /*.button_power_timeout           =*/ 0,    // seconds
    /*.button_client_timeout          =*/ 0,    // seconds
    /*.button_discover_timeout        =*/ 0,    // seconds
    /*.button_filter_timeout          =*/ 0,    // seconds
#ifdef BLE_UART_LOOPBACK_TRACE
    /*.button_uart_timeout            =*/ 15,   // seconds
#endif
};

// Following structure defines UART configuration
const BLE_PROFILE_PUART_CFG pes_puart_cfg =
{
    /*.baudrate   =*/ 115200,
#ifdef GATT_DB_ENABLE_UART
    /*.txpin      =*/ GPIO_PIN_UART_TX,
    /*.rxpin      =*/ GPIO_PIN_UART_RX,
#else
    /*.txpin      =*/ PUARTDISABLE | GPIO_PIN_UART_TX,
    /*.rxpin      =*/ PUARTDISABLE | GPIO_PIN_UART_RX,
#endif
};

// NVRAM save area
HOSTINFO pes_hostinfo;
//pointer to the generated part of hostinfo assuming it is the beginning of the hostinfo
__HOSTINFO *p_hostinfo_generated = &pes_hostinfo.generated;

UINT16 	pes_connection_handle      = 0;                  // HCI handle of connection, not zero when connected
BD_ADDR pes_remote_addr            = {0, 0, 0, 0, 0, 0}; // Address of currently connected client

// ToDo: Add your static variables here

/******************************************************
 *               Function Definitions
 ******************************************************/

// Application initialization
APPLICATION_INIT()
{
    bleapp_set_cfg((UINT8 *)gatt_database,
                   gatt_database_len,
                   (void *)&pes_cfg,
                   (void *)&pes_puart_cfg,
                   (void *)&pes_gpio_cfg,
                   pes_create);
}

/* ************************************************************** */

#define LED_PIN 28

#define TRANSFER_BUFFER_SIZE 30
#define MAX_BUFFER_SIZE 2048
//#define MIN(a, b) ((a) < (b) ? (a) : (b))

typedef enum {
    ENCODING_4_2_2,
    ENCODING_2_2_2
} ENCODING_TYPE;

typedef struct
{
    UINT16 size;
    UINT16 maxSize;
    UINT8 *buffer;
	ENCODING_TYPE encoding;
} RecordingInfo;

typedef struct
{
    UINT16 size;
    UINT16 offset;
    UINT16 maxSize;
    UINT8 *buffer;
} TransferInfo;


extern void setTime(UINT32 time);
extern void incrementTime();
extern void initialize();
extern void printBuffer2(UINT8 *buf, UINT16 len, int spacing, int linebreak);
extern void mymemcpy(UINT8 *to, UINT8 *from, UINT16 len);
extern UINT32 GetRandom(UINT32 low, UINT32 high);
extern void SetRecordingInfo(RecordingInfo *info, UINT8 *buf, UINT16 maxSize, ENCODING_TYPE encoding);
extern void AddRecordingRecord(RecordingInfo *info, UINT32 time, UINT16 temperature, UINT16 humidity);
extern UINT16 tempRead();
extern UINT16 humidityRead();
extern void readSensors();
extern BOOL tempSetNextTransferBlock(RecordingInfo *info);
extern void sprintBuffer2(char *s, UINT8 *buf, UINT16 len, int spacing, int linebreak);

extern UINT32 currentTime;
extern UINT16 sensorRecordInterval;
extern UINT32 sensorNextReadTime;

extern RecordingInfo recordings;
extern TransferInfo transferRecordings;
extern ENCODING_TYPE encoding;

extern UINT32 temperatureRandomLow;
extern UINT32 temperatureRandomHigh;
extern UINT32 humidityRandomLow;
extern UINT32 humidityRandomHigh;

RecordingInfo recordings;
TransferInfo transferRecordings;

UINT8 buffer[MAX_BUFFER_SIZE];
UINT8 transferBuffer[TRANSFER_BUFFER_SIZE];

UINT32 currentTime = 0;
UINT16 sensorRecordInterval = 30;
UINT32 sensorNextReadTime;

UINT32 temperatureRandomLow = 10;
UINT32 temperatureRandomHigh = 20;
UINT32 humidityRandomLow = 50;
UINT32 humidityRandomHigh = 90;


ENCODING_TYPE encoding = ENCODING_4_2_2;

void mymemcpy(UINT8 *to, UINT8 *from, UINT16 len)
{
	UINT16 i;
	for (i=0; i<len; i++)
	{
		*to = *from;
		from++;
		to++;
	}
}

UINT32 m_w = 521288629;
UINT32 m_z = 362436069;
UINT32 GetUint()
{
    m_z = 36969 * (m_z & 65535) + (m_z >> 16);
    m_w = 18000 * (m_w & 65535) + (m_w >> 16);
    return (m_z << 16) + m_w;
}

UINT32 GetRandom(UINT32 low, UINT32 high)
{
	UINT32 value = GetUint();
	value = value % (high-low) + low;
	return value;
}

void SetRecordingInfo(RecordingInfo *info, UINT8 *buf, UINT16 maxSize, ENCODING_TYPE encoding)
{
	info->size = 0;
	info->maxSize = maxSize;
	info->buffer = buf;
	info->encoding = encoding;
}


void AddRecordingRecord_4_2_2(RecordingInfo *info, UINT32 time, UINT16 temperature, UINT16 humidity)
{
	UINT16 len = 8;

	if (info->size + len > info->maxSize)
	{
		mymemcpy(info->buffer, info->buffer+len, info->size - len);
		info->size -= len;
	}
	mymemcpy(info->buffer + info->size, (UINT8 *) &time, 4);
	info->size += 4;
	mymemcpy(info->buffer + info->size, (UINT8 *) &temperature, 2);
	info->size += 2;
	mymemcpy(info->buffer + info->size, (UINT8 *) &humidity, 2);
	info->size += 2;
}

void AddRecordingRecord_2_2_2(RecordingInfo *info, UINT32 time, UINT16 temperature, UINT16 humidity)
{
	UINT16 len = 6;

    if (info->size == 0)
	{
		mymemcpy(info->buffer, (UINT8 *) &time, 4);
		info->size = 4;
	}

	UINT32 *origTime = (UINT32 *) info->buffer;
	UINT16 offsetTime = (UINT16) (time - *origTime);
	//printf("time: %lu  offset: %hu\n", time, offsetTime);

	if (info->size + len > info->maxSize)
	{
		//printf("before");
		//printBuffer2(info->buffer, info->size, 0, 32);
		mymemcpy(info->buffer, info->buffer+len, info->size - 4 - len);
		info->size -= len;
		//printf("after");
		//printBuffer2(info->buffer, info->size, 0, 32);
	}
	mymemcpy(info->buffer + info->size, (UINT8 *) &offsetTime, 2);
	info->size += 2;
	mymemcpy(info->buffer + info->size, (UINT8 *) &temperature, 2);
	info->size += 2;
	mymemcpy(info->buffer + info->size, (UINT8 *) &humidity, 2);
	info->size += 2;
	//printf("after2");
	//printBuffer2(info->buffer, info->size, 0, 32);
    //printf("size: %d\n", info->size);
}

void AddRecordingRecord(RecordingInfo *info, UINT32 time, UINT16 temperature, UINT16 humidity)
{

	switch (info->encoding)
	{
		case ENCODING_4_2_2:
			AddRecordingRecord_4_2_2(info, time, temperature, humidity);
			break;
		case ENCODING_2_2_2:
			AddRecordingRecord_2_2_2(info, time, temperature, humidity);
			break;
		default:
			break;
	}
}

UINT16 tempRead()
{
	UINT16 value = GetRandom(temperatureRandomLow, temperatureRandomHigh);
	return value;
}

UINT16 humidityRead()
{
	UINT16 value = GetRandom(humidityRandomLow, humidityRandomHigh);
	return value;
}

void readSensors()
{
	if (currentTime < sensorNextReadTime)
		return;

	UINT16 temperature = tempRead();
	UINT16 humidity = humidityRead();
	AddRecordingRecord(&recordings, currentTime, temperature, humidity);
	sensorNextReadTime = currentTime + sensorRecordInterval;
}

BOOL SetNextTransferBlock(RecordingInfo *info)
{
	UINT16 remaining;
	UINT8 flag;
	UINT16 transferLength;

	remaining = info->size - transferRecordings.offset;
	transferLength = MIN(transferRecordings.maxSize - 3, remaining);
	remaining -= transferLength;

    flag = ((transferRecordings.offset == 0) << 1 |
			(remaining == 0)
		);

    mymemcpy(transferRecordings.buffer, &flag, 1);
    mymemcpy(transferRecordings.buffer + 1, (UINT8 *) &transferLength, 2);
	mymemcpy(transferRecordings.buffer + 3,
		info->buffer + transferRecordings.offset,
		transferLength);

	transferRecordings.size = transferLength+3;
	transferRecordings.offset += transferLength;
	return flag;
}


void initialize()
{
	sensorNextReadTime =  currentTime == 0 ? 0 : currentTime + sensorRecordInterval;

	SetRecordingInfo(&recordings, buffer, MAX_BUFFER_SIZE, encoding);
	transferRecordings.size = 0;
	transferRecordings.offset = 0;
	transferRecordings.buffer = transferBuffer;
	transferRecordings.maxSize = TRANSFER_BUFFER_SIZE;
}

void setTime(UINT32 time)
{
	currentTime = time;
}

void incrementTime()
{
	currentTime++;
}

/* ************************************************************** */

ulong currentTimeMS = 0;
ulong ledTimerMS = 0;

extern void set_led(BOOL value, ulong durationMS);
extern void pes_timer_ms(UINT32 arg);

void set_led(BOOL value, ulong durationMS)
{
	gpio_setPinOutput(LED_PIN / 16, LED_PIN % 16, value ? 0 : 255);
	if (value == TRUE)
	{
		if (durationMS > 0)
		{
			ledTimerMS = currentTimeMS + durationMS;
		}
	}
}

ulong currentTimeMSTicks = 0;

void pes_timer_ms(UINT32 arg)
{
	currentTimeMSTicks++;
	currentTimeMS += (currentTimeMSTicks % 2 == 1) ? 13 : 12;
	if (currentTimeMS > ledTimerMS)
	{
		set_led(FALSE, 0);
	}
}

// Create device
void pes_create(void)
{
	extern UINT8 bleprofile_adv_num;
	extern UINT8 bleprofile_scanrsp_num;

    ble_trace0("create()");
    ble_trace0(bleprofile_p_cfg->ver);

	bleprofile_adv_num = 0x0;
	bleprofile_scanrsp_num = 0x0;

    // dump the database to debug uart.
    legattdb_dumpDb();

    bleprofile_Init(bleprofile_p_cfg);
    bleprofile_GPIOInit(bleprofile_gpio_p_cfg);

    gpio_configurePin(LED_PIN / 16, LED_PIN % 16, GPIO_OUTPUT_ENABLE, 0);
    set_led(FALSE, 0); // off

    // Initialized ROM code which will monitor the battery
    blebat_Init();

    // Read NVRAM
    bleprofile_ReadNVRAM(VS_BLE_HOST_LIST, sizeof(pes_hostinfo), (UINT8 *)&pes_hostinfo);

    // register connection up and connection down handler.
    bleprofile_regAppEvtHandler(BLECM_APP_EVT_LINK_UP, pes_connection_up);
    bleprofile_regAppEvtHandler(BLECM_APP_EVT_LINK_DOWN, pes_connection_down);
    bleprofile_regAppEvtHandler(BLECM_APP_EVT_ADV_TIMEOUT, pes_advertisement_stopped);

    // handler for Encryption changed.
    blecm_regEncryptionChangedHandler(pes_encryption_changed);

    // handler for Bond result
    lesmp_regSMPResultCb((LESMP_SINGLE_PARAM_CB) pes_smp_bond_result);

    // register to process client writes
    legattdb_regWriteHandleCb((LEGATTDB_WRITE_CB)pes_write_handler);

    // register interrupt handler
    bleprofile_regIntCb((BLEPROFILE_SINGLE_PARAM_CB) pes_interrupt_handler);

    //registers timer
    pes_reg_timer();

    // advertise first vendor specific service
    if(sizeof(pes_uuid_main_service) > 1)
    {
    	// total length should be less than 31 bytes
    	BLE_ADV_FIELD adv[3];
        BLE_ADV_FIELD scr[1];

		// flags
		adv[0].len     = 1 + 1;
		adv[0].val     = ADV_FLAGS;
		adv[0].data[0] = LE_LIMITED_DISCOVERABLE | BR_EDR_NOT_SUPPORTED;

		adv[1].len     = sizeof(pes_uuid_main_service) + 1;
		adv[1].val     = sizeof(pes_uuid_main_service) == 16 ? ADV_SERVICE_UUID128_COMP : ADV_SERVICE_UUID16_COMP;
		memcpy(adv[1].data, &pes_uuid_main_service[0], sizeof(pes_uuid_main_service));

        // Tx power level
        adv[2].len     = TX_POWER_LEN+1;
        adv[2].val     = ADV_TX_POWER_LEVEL;
        adv[2].data[0] = bleprofile_p_cfg->tx_power_level;

		// name
        scr[0].len      = strlen(bleprofile_p_cfg->local_name) + 1;
        scr[0].val      = ADV_LOCAL_NAME_COMP;
        memcpy(scr[0].data, bleprofile_p_cfg->local_name, scr[0].len - 1);

		bleprofile_GenerateADVData(adv, 3);
        bleprofile_GenerateScanRspData(scr, 1);
    }

    blecm_setTxPowerInADV(0);

    // start device advertisements.  By default Advertisements will contain flags, device name,
    // appearance and main service UUID.
    bleprofile_Discoverable(HIGH_UNDIRECTED_DISCOVERABLE, NULL);

    // ToDo: Do your initialization on app startup

    /* add adc <meehan@parc.com> */
    adc_config();
//    bleprofile_LEDBlink((UINT16)1000, (UINT16) 1000, (UINT8) 5);

//    bleprofile_KillTimer();
//    bleprofile_regTimerCb(pes_timer_ms, pes_timeout);
//    bleprofile_StartTimer();

    initialize();
}

// Connection up callback function is called on every connection establishment
void pes_connection_up(void)
{
	pes_connection_handle = (UINT16)emconinfo_getConnHandle();
	UINT8 *bda = (UINT8 *)emconninfo_getPeerPubAddr();

    // Save address of the connected device and print it out.
    memcpy(pes_remote_addr, bda, sizeof(pes_remote_addr));

    ble_trace3("connection_up: %08x%04x h=%d",
                (pes_remote_addr[5] << 24) + (pes_remote_addr[4] << 16) +
                (pes_remote_addr[3] << 8) + pes_remote_addr[2],
                (pes_remote_addr[1] << 8) + pes_remote_addr[0],
                pes_connection_handle);

    //set_led(TRUE, 2000);

    // Prepare generated code for connection - write persistent values from __HOSTINFO to GATT DB
    __on_connection_up();

	// ToDo: Write custom persistent values into GATT database using functions
	// changed_<service_name>_<char_name>() generated by smart disigner

    // If device supports a single connection, stop advertising
    bleprofile_Discoverable(NO_DISCOVERABLE, NULL);

    // If security is required for every connection following function will start bonding or
    // will setup encryption.  No indications or notifications should be sent until
    // encryption is not done.
    if (bleprofile_p_cfg->encr_required & SECURITY_REQUEST)
    {
        if (emconninfo_deviceBonded())
        {
            ble_trace0("device bonded");
        }
        else
        {
            ble_trace0("device not bonded");
            lesmp_sendSecurityRequest();
        }
    }
}

// Connection down callback
void pes_connection_down(void)
{
    ble_trace1("connection_down:handle:%d", pes_connection_handle);

    pes_connection_handle = 0;

    // If disconnection was caused by the peer, start low advertisements
    bleprofile_Discoverable(LOW_UNDIRECTED_DISCOVERABLE, NULL);

    ble_trace2("ADV start: %08x%04x",
                  (pes_remote_addr[5] << 24 ) + (pes_remote_addr[4] <<16) +
                  (pes_remote_addr[3] << 8 ) + pes_remote_addr[2],
                  (pes_remote_addr[1] << 8 ) + pes_remote_addr[0]);
}

// Callback function indicates to the application that advertising has stopped.
// restart advertisement if needed
void pes_advertisement_stopped(void)
{
    ble_trace0("ADV stop!!!!");

	// If disconnection was caused by the peer, start low advertisements
    bleprofile_Discoverable(LOW_UNDIRECTED_DISCOVERABLE, NULL);
}

// Process SMP bonding result.  If pairing is successful with the central device,
// save its BDADDR in the NVRAM and initialize associated data
void pes_smp_bond_result(LESMP_PARING_RESULT  result)
{
    ble_trace1("smp_bond_result %02x", result);

    if (result == LESMP_PAIRING_RESULT_BONDED)
    {
        // saving bd_addr in nvram
        UINT8 *bda;
        UINT8 writtenbyte;

        bda = (UINT8 *)emconninfo_getPeerPubAddr();

        // initialize persistent values in the hostinfo to add bonded peer
        pes_add_bond(bda);

        // ToDo: initialize persistent variables in HOSTINFO

        //now write hostinfo into NVRAM
        writtenbyte = bleprofile_WriteNVRAM(VS_BLE_HOST_LIST, sizeof(pes_hostinfo), (UINT8 *)&pes_hostinfo);
        ble_trace1("NVRAM write:%04x", writtenbyte);
    }
}

// Notification from the stack that encryption has been set.
void pes_encryption_changed(HCI_EVT_HDR *evt)
{
    UINT8 *bda = emconninfo_getPeerPubAddr();

    ble_trace2("encryption changed %08x%04x",
                (bda[5] << 24) + (bda[4] << 16) +
                (bda[3] << 8) + bda[2],
                (bda[1] << 8) + bda[0]);

    // ToDo: do your on-encryption-change actions here.

    // Slow down the pace of master polls to save power.  Following request asks
    // host to setup polling every 100-500 msec, with link supervision timeout 5 seconds.
    bleprofile_SendConnParamUpdateReq(80, 400, 0, 500);
}

// Process write request or command from peer device
int pes_write_handler(LEGATTDB_ENTRY_HDR *p)
{
    UINT8  writtenbyte;
    UINT16 handle   = legattdb_getHandle(p);
    int    len      = legattdb_getAttrValueLen(p);
    UINT8  *attrPtr = legattdb_getAttrValue(p);
    BOOL changed;

    ble_trace1("write_handler: handle %04x", handle);

    changed = __write_handler(handle, len, attrPtr);

    // Save update to NVRAM if it has been changed.
    if (changed)
    {
		writtenbyte = bleprofile_WriteNVRAM(VS_BLE_HOST_LIST, sizeof(pes_hostinfo), (UINT8 *)&pes_hostinfo);
		ble_trace1("NVRAM write:%04x", writtenbyte);
    }
    return 0;
}

// Three Interrupt inputs (Buttons) can be handled here.
// If the following value == 1, Button is pressed. Different than initial value.
// If the following value == 0, Button is depressed. Same as initial value.
// Button1 : value&0x01
// Button2 : (value&0x02)>>1
// Button3 : (value&0x04)>>2
void pes_interrupt_handler(UINT8 value)
{
    // ToDo: handle the interrupts here.
}

// Process indication confirmation.  if client service indication, each indication
// should be acknowledged before the next one can be sent.
void pes_indication_cfm(void)
{
}

//------ generated code

UINT16 application_read_adc_voltage_from_gpio(UINT8 gpio_number){
	return adc_readVoltage(adc_convertGPIOtoADCInput(gpio_number));
}


// It will be called every 1 sec
void pes_timer_1s()
{
	ble_trace0("pes_timer_1s()");

    UINT16 value = application_read_adc_voltage_from_gpio(33);
	//ble_trace1("  voltage %04x", value);

	incrementTime();
	readSensors();

	store_in_db_sensor_service_time((UINT8 *)&currentTime, 4, TRUE, TRUE);

	//bleprofile_LEDBlink((UINT16)1000, (UINT16) 1000, (UINT8) 10);
}



// It will be called at the write handler and should return TRUE if any persistent value is changed
BOOL on_write_sensor_service_set_recording_info(int len, UINT8 *attrPtr)
{
    //Todo: do you actions here when value is written by the peer
    // and return TRUE if any persistent value is changed
	ble_trace0("on_write_sensor_service_set_recording_info()");
    return FALSE;
}

// It will be called at the write handler and should return TRUE if any persistent value is changed
BOOL on_write_sensor_service_temperature_history(int len, UINT8 *attrPtr)
{
	UINT8 flag;

    ble_trace0("on_write_sensor_service_temperature_history()");

	transferRecordings.offset = 0;
	flag = SetNextTransferBlock(&recordings);

	store_in_db_sensor_service_temperature_history((UINT8 *)transferRecordings.buffer,
			100, TRUE, TRUE);

	return FALSE;
}

// It will be called at the write handler and should return TRUE if any persistent value is changed
BOOL on_write_sensor_service_humidity_history(int len, UINT8 *attrPtr)
{
    //Todo: do you actions here when value is written by the peer
    // and return TRUE if any persistent value is changed
	ble_trace0("on_write_sensor_service_humidity_history()");
    return FALSE;
}

// It will be called at the write handler and should return TRUE if any persistent value is changed
BOOL on_write_sensor_service_time(int len, UINT8 *attrPtr)
{
    //Todo: do you actions here when value is written by the peer
    // and return TRUE if any persistent value is changed
	ble_trace0("on_write_sensor_service_time()");
	currentTime = *((uint32 *) attrPtr);
	return FALSE;
}

// It will be called at the write handler and should return TRUE if any persistent value is changed
BOOL on_write_sensor_service_recording_info(int len, UINT8 *attrPtr)
{
	UINT16 value = *((UINT16 *)attrPtr);
	ble_trace0("on_write_sensor_service_recording_info()");
	ble_trace1("recording %04x", value);
	sensorRecordInterval = value;
	initialize();
	return FALSE;
}

// It will be called at the write handler and should return TRUE if any persistent value is changed
BOOL on_write_sensor_service_blink(int len, UINT8 *attrPtr)
{
    UINT16 value = *((UINT16 *)attrPtr);
	ble_trace1("blink %04x", value);
	set_led(TRUE, value);
    return FALSE;
}

// It will be called at the write handler and should return TRUE if any persistent value is changed
BOOL on_write_sensor_service_history(int len, UINT8 *attrPtr)
{
    //Todo: do you actions here when value is written by the peer
    // and return TRUE if any persistent value is changed
    return FALSE;
}

// It will be called at the write handler and should return TRUE if any persistent value is changed
BOOL on_write_sensor_service_call_history(int len, UINT8 *attrPtr)
{
	set_led(TRUE, 500);

	UINT16 value = *((UINT16 *)attrPtr);
	if (value != 0)
	{
		transferRecordings.offset = 0;
		//transferRecordings.maxSize = value;
	}
	UINT8 flag;
	flag = SetNextTransferBlock(&recordings);
	store_in_db_sensor_service_history((UINT8*) transferRecordings.buffer, transferRecordings.size, TRUE, TRUE);
    return FALSE;
}

// It will be called every fine timer tick
void pes_timer_fine()
{
    //Todo: do you actions here every fine timer tick
	pes_timer_ms(0);
}

